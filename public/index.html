<!DOCTYPE html>
<html>
<head>
  <title>Pixel Game</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
      background-color: black;
      /* Establecer las dimensiones del lienzo para que ocupen todo el ancho y alto de la pantalla */
      width: 100vw;
      height: 100vh;
    }

    /* Estilo para la barra de zoom */
    #zoomBar {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%; 
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- Barra de zoom -->
  <input type="range" id="zoomBar" min="1" max="5" value="1" step="0.1">

  <script>
    const ws = new WebSocket('ws://localhost:3000');
    let zoomLevel = 1;  

    console.log("llamando ws");
    ws.onopen = () => {
      console.log('WebSocket connected');
      // Envia un mensaje JSON al servidor WebSocket con las coordenadas iniciales y el tamaño de la vista
      const message = JSON.stringify({ x: 0, y: 0, viewWidth: window.innerWidth / zoomLevel, viewHeight: window.innerHeight / zoomLevel });
      ws.send(message);
    };

    ws.onmessage = (event) => {
      const worldView = JSON.parse(event.data);
      renderWorldView(worldView.view);
    };

    console.log("ws after");

    // Manejar el cambio en la barra de zoom
    const zoomBar = document.getElementById('zoomBar');
    
    zoomBar.addEventListener('input', () => {
      zoomLevel = parseFloat(zoomBar.value);
      const message = JSON.stringify({ x: 0, y: 0, viewWidth: window.innerWidth / zoomLevel, viewHeight: window.innerHeight / zoomLevel });
      ws.send(message);
    });

    function renderWorldView(worldView) {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const cellSize = Math.min(canvas.width / worldView[0].length, canvas.height / worldView.length);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < worldView.length; y++) {
        for (let x = 0; x < worldView[y].length; x++) {
          const cell = worldView[y][x];
          const terrain = cell.terrain;

          // Ajustar la posición según el nivel de zoom
          const adjustedX = x * cellSize * zoomLevel;
          const adjustedY = y * cellSize * zoomLevel;
          const adjustedCellSize = cellSize * zoomLevel;

          switch (terrain) {
            case 'water':
              ctx.fillStyle = 'blue';
              break;
            case 'sand':
              ctx.fillStyle = 'yellow';
              break;
            case 'grass':
              ctx.fillStyle = 'green';
              break;
            case 'mountain':
              ctx.fillStyle = 'gray';
              break;
            default:
              ctx.fillStyle = 'white';
              break;
          }

          // Dibujar el terreno con el tamaño de celda ajustado por el nivel de zoom
          ctx.fillRect(adjustedX, adjustedY, adjustedCellSize, adjustedCellSize);

          /*if (cell.entity === 'tree') {
            ctx.fillStyle = 'brown';
            ctx.fillRect(x * cellSize + 7, y * cellSize + 3, 6, 14);
            ctx.fillStyle = 'green';
            ctx.fillRect(x * cellSize + 4, y * cellSize, 12, 10);
          }*/

           // Dibujar entidades
           const entity = cell.entity;
          if (entity === 'palmTree') {
            // Dibujar una palmera (color marrón para el tronco y verde para las hojas)
            ctx.fillStyle = 'brown';
            ctx.fillRect(x * cellSize + cellSize * 0.3, y * cellSize + cellSize * 0.5, cellSize * 0.4, cellSize * 0.3);
            ctx.fillStyle = 'green';
            ctx.beginPath();
            ctx.arc(x * cellSize + cellSize * 0.5, y * cellSize + cellSize * 0.3, cellSize * 0.2, 0, Math.PI * 2);
            ctx.fill();
          }else if (cell.entity === 'tree') {
            ctx.fillStyle = 'brown';
            ctx.fillRect(x * cellSize + 7, y * cellSize + 3, 6, 14);
            ctx.fillStyle = 'green';
            ctx.fillRect(x * cellSize + 4, y * cellSize, 12, 10);
          }
          else if (entity === 'crab') {
            // Dibujar un cangrejo (color rojo)
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(x * cellSize + cellSize * 0.5, y * cellSize + cellSize * 0.5, cellSize * 0.4, 0, Math.PI * 2);
            ctx.fill();
          } else if (entity === 'flower') {
            // Dibujar una flor (color rosa)
            ctx.fillStyle = 'pink';
            ctx.beginPath();
            ctx.arc(x * cellSize + cellSize * 0.5, y * cellSize + cellSize * 0.5, cellSize * 0.2, 0, Math.PI * 2);
            ctx.fill();
          } else if (entity === 'butterfly') {
            // Dibujar una mariposa (color amarillo)
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.moveTo(x * cellSize + cellSize * 0.5, y * cellSize + cellSize * 0.3);
            ctx.lineTo(x * cellSize + cellSize * 0.3, y * cellSize + cellSize * 0.7);
            ctx.lineTo(x * cellSize + cellSize * 0.5, y * cellSize + cellSize * 0.5);
            ctx.lineTo(x * cellSize + cellSize * 0.7, y * cellSize + cellSize * 0.7);
            ctx.closePath();
            ctx.fill();
          } else if (entity === 'rock') {
            // Dibujar una roca (color gris)
            ctx.fillStyle = 'gray';
            ctx.beginPath();
            ctx.arc(x * cellSize + cellSize * 0.5, y * cellSize + cellSize * 0.5, cellSize * 0.3, 0, Math.PI * 2);
            ctx.fill();
          } else if (entity === 'eagle') {
            // Dibujar un águila (color negro)
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.moveTo(x * cellSize + cellSize * 0.5, y * cellSize + cellSize * 0.3);
            ctx.lineTo(x * cellSize + cellSize * 0.3, y * cellSize + cellSize * 0.7);
            ctx.lineTo(x * cellSize + cellSize * 0.5, y * cellSize + cellSize * 0.5);
            ctx.lineTo(x * cellSize + cellSize * 0.7, y * cellSize + cellSize * 0.7);
            ctx.closePath();
            ctx.fill();
        }

        // Ajustar la posición de las entidades según el nivel de zoom
        const adjustedEntityX = adjustedX + adjustedCellSize * 0.5;
        const adjustedEntityY = adjustedY + adjustedCellSize * 0.5;

      }
    }
  }
  </script>
</body>
</html>
